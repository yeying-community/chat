# 用户手册

本文档用于介绍当前系统的整体架构、授权机制以及核心功能。

## 系统概览

本系统基于 Next.js（前端）构建，并集成 YeYing 钱包与 `@yeying-community/web3-bs` SDK。鉴权从 SIWE 切换为 UCAN，支持一次授权后同时访问多个后端服务（如 Router 与 WebDAV）。

核心组成：

- 前端：Next.js（本项目）
- 钱包：YeYing Wallet（EIP-1193）
- 鉴权：UCAN（Root + Invocation）
- 后端：Router（OpenAI-compatible）、WebDAV（存储服务）

## 鉴权流程（UCAN）

1. 连接钱包后，前端请求钱包生成 UCAN Session Key。
2. 使用钱包签名生成 Root UCAN（基于 SIWE 签名），并存入本地。
3. 发起请求时，生成 Invocation UCAN 并写入 `Authorization: Bearer <UCAN>`。

Root UCAN 可同时用于多个后端服务，Invocation UCAN 会根据目标后端的 `audience` 与 `capabilities` 生成。

## 多后端登录与调用

一次授权后，可同时访问：

- Router：OpenAI-compatible 接口（模型、聊天、用量等）
- WebDAV：文件/配额相关接口

前端会为不同后端生成不同的 Invocation UCAN，并自动携带授权头。

## 配置项

主要环境变量：

- `WEBDAV_BACKEND_BASE_URL`：WebDAV 后端基础地址（不含路径）
- `WEBDAV_BACKEND_PREFIX`：WebDAV 路径前缀（默认 `/dav`，可选修改）
- `ROUTER_BACKEND_URL`：Router 默认后端地址（用于前端默认值）
- 通用 UCAN 能力：固定为 `profile/read`

提示：`WEBDAV_BACKEND_PREFIX` 只用于 WebDAV 协议接口路径（兼容第三方 WebDAV 客户端挂载），
配额、SIWE、UCAN 等 HTTP 接口不加前缀。

## 本地存储

用于 UCAN 授权的关键本地存储：

- `localStorage`
  - `currentAccount`：当前钱包地址
  - `ucanRootExp`：Root UCAN 过期时间（毫秒）
  - `ucanRootIss`：Root UCAN Issuer
- `IndexedDB`
  - DB: `yeying-web3`
  - Store: `ucan-sessions`（Root UCAN 与 Session 信息）

当 Root UCAN 过期或账户变化时，需要重新授权。

## UCAN Token 有效期、刷新与钱包解锁

### Token 生命周期（当前实现）

- **Root UCAN**：默认有效期为 **24 小时**（`@yeying-community/web3-bs` 默认值 `24 * 60 * 60 * 1000`）。
- **Invocation UCAN**：默认有效期为 **5 分钟**（每次请求按后端实时生成，默认值 `5 * 60 * 1000`）。
- **钱包 UCAN Session Key**：由钱包返回 `expiresAt`；前端会做短期缓存，并在接近过期时重新获取。

### 刷新策略（登录成功后）

- **Router 请求**：会自动尝试获取/刷新 UCAN Session，然后生成新的 Invocation UCAN 并发起请求。
- **WebDAV 同步**：优先复用当前会话；会话不可用时，请求会失败并在后续交互中重试。
- **Root UCAN**：不会无感无限续期；当 Root 过期、账户切换或能力不匹配时，必须重新授权。

### 为什么会提示“解锁钱包”

出现“切到钱包页面后提示解锁”通常是正常安全行为，不是 Chat 单点故障，常见原因：

1. 钱包插件有自动锁定策略（长时间无操作、浏览器切后台等）。
2. 当前 UCAN Session 已过期，需要向钱包重新申请会话。
3. 需要钱包参与签名流程（例如重建 Root UCAN 或签发新的会话相关能力）。

本质上：**私钥/签名能力在钱包侧受保护**，前端无法绕过“解锁”步骤。

### 什么时候只解锁，什么时候要重新授权

- **只需解锁钱包**：Root UCAN 仍在有效期内、账户未变、能力未变；解锁后可继续自动签发 Invocation UCAN。
- **需要重新连接/授权**：`ucanRootExp` 已过期，或 `currentAccount` 与 Root Issuer 不一致，或能力发生变化。

## 运行与端口

开发模式默认端口为 `3020`：

```bash
npm run dev
```

生产模式：

```bash
npm run build
npm run start
```

---

## 面具 (Mask)

### 什么是面具？它和提示词的区别是什么？

面具 = 多个预设提示词 + 模型设置 + 对话设置。

其中预设提示词（Contextual Prompts）一般用于 In-Context Learning，用于让 ChatGPT 生成更加符合要求的输出，也可以增加系统约束或者输入有限的额外知识。

模型设置则顾名思义，使用此面具创建的对话都会默认使用对应的模型参数。

对话设置是与对话体验相关的一系列设置，我们会在下方的章节中依次介绍。

### 如何添加一个预设面具？

目前仅能够通过编辑源代码的方式添加预设面具，请根据需要编辑 [mask](../app/masks/) 目录下对应语言的文件即可。

编辑步骤如下：

1. 在 Chat 中配置好一个面具；
2. 使用面具编辑页面的下载按钮，将面具保存为 JSON 格式；
3. 让 ChatGPT 帮你将 json 文件格式化为对应的 ts 代码；
4. 放入对应的 .ts 文件。

后续会增加使用旁加载的方式加载面具。

## 对话 (Chat)

### 对话框上方的按钮的作用

在默认状态下，将鼠标移动到按钮上，即可查看按钮的文字说明，我们依次介绍：

- 对话设置：当前对话的设置，它与全局设置的关系，请查看下一小节的说明；
- 颜色主题：点击即可在自动、暗黑、浅色之间轮换；
- 快捷指令：项目内置的快捷填充预设提示词，也可以在对话框中输入 / 进行搜索；
- 所有面具：进入面具页面；
- 清除聊天：插入一个清除标记，标记上方的聊天将不会发给 GPT，效果相当于清除了当前对话，当然，你也可以再次点击该按钮，可取消清除；
- 模型设置：更改当前对话的模型，注意，此按钮只会修改当前对话的模型，并不会修改全局默认模型。

### 对话内设置与全局设置的关系

目前有两处设置入口：

1. 页面左下角的设置按钮，进入后是全局设置页；
2. 对话框上方的设置按钮，进入后是对话设置页。

在新建对话后，该对话的设置默认与全局设置保持同步，修改全局设置，则新建对话的对话内设置也会被同步修改。

一旦用户手动更改过对话内设置，则对话内设置将与全局设置断开同步，此时更改全局设置，将不会对该对话生效。

如果想恢复两者的同步关系，可以将“对话内设置 -> 使用全局设置”选项勾选。

### 对话内设置项的含义

点开对话框上方的按钮，进入对话内设置，内容从上到下依次为：

- 预设提示词列表：可以增加、删除、排序预设提示词
- 角色头像：顾名思义
- 角色名称：顾名思义
- 隐藏预设对话：隐藏后，预设提示词不会出现在聊天界面
- 使用全局设置：用于表示当前对话是否使用全局对话设置
- 模型设置选项：剩余的选项与全局设置选项含义一致，见下一小节

### 全局设置项的含义

- model / temperature / top_p / max_tokens / presence_penalty / frequency_penalty 均为 ChatGPT 的设置参数，详情请查阅 OpenAI 官方文档，再次不再赘述；
- 注入系统级提示信息、用户输入预处理：详情请看 [https://github.com/Yidadaa/ChatGPT-Next-Web/issues/2144](https://github.com/Yidadaa/ChatGPT-Next-Web/issues/2144)
- 附带历史消息数：用户每次输入消息并发送时，所携带的最近 n 条消息数量；
- 历史消息长度压缩阈值：当已经产生的聊天字数达到该数值以后，则自动触发历史摘要功能；
- 历史摘要：是否启用历史摘要功能。

### 什么是历史摘要？

历史摘要功能，也是历史消息压缩功能，是保证长对话场景下保持历史记忆的关键，合理使用该功能可以在不丢失历史话题信息的情况下，节省所使用的 token。

由于 ChatGPT API 的长度限制，我们以 3.5 模型为例，它只能接受小于 4096 tokens 的对话消息，一旦超出这个数值，就会报错。

同时为了让 ChatGPT 理解我们对话的上下文，往往会携带多条历史消息来提供上下文信息，而当对话进行一段时间之后，很容易就会触发长度限制。

为了解决此问题，我们增加了历史记录压缩功能，假设阈值为 1000 字符，那么每次用户产生的聊天记录超过 1000 字符时，都会将没有被总结过的消息，发送给 ChatGPT，让其产生一个 100 字左右的摘要。

这样，历史信息就从 1000 字压缩到了 100 字，这是一种有损压缩，但已能满足大多数使用场景。

### 什么时候应该关闭历史摘要？

历史摘要可能会影响 ChatGPT 的对话质量，所以如果对话场景是翻译、信息提取等一次性对话场景，请直接关闭历史摘要功能，并将历史消息数设置为 0。

### 当用户发送一条消息时，有哪些信息被发送出去了？

当用户在对话框输入了一条消息后，发送给 ChatGPT 的消息，包含以下几个部分：

1. 系统级提示词：用于尽可能贴近 ChatGPT 官方 WebUI 的使用体验，可在设置中关闭此信息；
2. 历史摘要：作为长期记忆，提供长久但模糊的上下文信息；
3. 预设提示词：当前对话内设置的预设提示词，用于 In-Context Learning 或者注入系统级限制；
4. 最近 n 条对话记录：作为短期记忆，提供短暂但精确的上下文信息；
5. 用户当前输入的消息。
